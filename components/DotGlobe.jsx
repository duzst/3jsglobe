"use client";
import React,{useEffect,useRef,useState}from"react";
import*as THREE from"three";
import{OrbitControls}from"three/examples/jsm/controls/OrbitControls.js";
export default function DotGlobe(){const containerRef=useRef(null);const[pointCount,setPointCount]=useState(3500);const[autoRotate,setAutoRotate]=useState(true);const[rotateSpeed,setRotateSpeed]=useState(0.6);const[dotSize,setDotSize]=useState(0.01);const sceneRef=useRef(null);const cameraRef=useRef(null);const rendererRef=useRef(null);const controlsRef=useRef(null);const pointsRef=useRef(null);const highlightRef=useRef(null);const raycasterRef=useRef(null);const mouseRef=useRef(new THREE.Vector2());useEffect(()=>{const container=containerRef.current;if(!container)return;const scene=new THREE.Scene();sceneRef.current=scene;const camera=new THREE.PerspectiveCamera(45,container.clientWidth/container.clientHeight,0.1,100);camera.position.set(0,0,2.8);cameraRef.current=camera;const renderer=new THREE.WebGLRenderer({antialias:true,alpha:true});renderer.setSize(container.clientWidth,container.clientHeight);renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2));rendererRef.current=renderer;container.appendChild(renderer.domElement);container.style.background="radial-gradient(1200px 800px at 20% 15%, rgba(120,160,255,0.18), transparent), radial-gradient(900px 700px at 80% 85%, rgba(255,120,200,0.10), transparent), #0b1021";const ambient=new THREE.AmbientLight(0xffffff,0.6);scene.add(ambient);const dir=new THREE.DirectionalLight(0xffffff,0.6);dir.position.set(5,5,5);scene.add(dir);const controls=new OrbitControls(camera,renderer.domElement);controls.enableDamping=true;controls.dampingFactor=0.08;controls.rotateSpeed=0.6;controls.enablePan=false;controls.minDistance=1.2;controls.maxDistance=8;controls.autoRotate=autoRotate;controls.autoRotateSpeed=rotateSpeed;controlsRef.current=controls;const raycaster=new THREE.Raycaster();raycaster.params.Points={threshold:0.03};raycasterRef.current=raycaster;const highlight=new THREE.Mesh(new THREE.SphereGeometry(0.025,16,16),new THREE.MeshBasicMaterial({color:0xff7a18}));highlight.visible=false;scene.add(highlight);highlightRef.current=highlight;const points=createPointCloud(pointCount,dotSize);scene.add(points);pointsRef.current=points;const onResize=()=>{if(!container)return;const{clientWidth,clientHeight}=container;renderer.setSize(clientWidth,clientHeight);camera.aspect=clientWidth/clientHeight;camera.updateProjectionMatrix()};window.addEventListener("resize",onResize);const onPointerMove=e=>{if(!renderer||!camera||!pointsRef.current)return;const rect=renderer.domElement.getBoundingClientRect();mouseRef.current.x=(e.clientX-rect.left)/rect.width*2-1;mouseRef.current.y=-((e.clientY-rect.top)/rect.height)*2+1};renderer.domElement.addEventListener("pointermove",onPointerMove);let stopped=false;const animate=()=>{if(stopped)return;requestAnimationFrame(animate);if(controlsRef.current){controlsRef.current.autoRotate=autoRotate;controlsRef.current.autoRotateSpeed=rotateSpeed;controlsRef.current.update()}if(raycasterRef.current&&pointsRef.current){raycasterRef.current.setFromCamera(mouseRef.current,camera);const intersects=raycasterRef.current.intersectObject(pointsRef.current);if(intersects&&intersects.length>0){const i=intersects[0].index;if(typeof i==="number"){const pos=pointsRef.current.geometry.attributes.position;const v=new THREE.Vector3(pos.getX(i),pos.getY(i),pos.getZ(i));highlight.position.copy(v);highlight.visible=true}}else{highlight.visible=false}}renderer.render(scene,camera)};animate();return()=>{stopped=true;window.removeEventListener("resize",onResize);renderer.domElement.removeEventListener("pointermove",onPointerMove);if(pointsRef.current){disposePoints(pointsRef.current);scene.remove(pointsRef.current);pointsRef.current=null}if(highlightRef.current){highlightRef.current.geometry.dispose();highlightRef.current.material.dispose();scene.remove(highlightRef.current)}controls.dispose();renderer.dispose();container.removeChild(renderer.domElement)}} ,[]);useEffect(()=>{if(!sceneRef.current)return;const scene=sceneRef.current;if(pointsRef.current){disposePoints(pointsRef.current);scene.remove(pointsRef.current);pointsRef.current=null}const fresh=createPointCloud(pointCount,dotSize);scene.add(fresh);pointsRef.current=fresh},[pointCount,dotSize]);const handleResetCamera=()=>{if(!cameraRef.current||!controlsRef.current)return;cameraRef.current.position.set(0,0,2.8);controlsRef.current.target.set(0,0,0);controlsRef.current.update()};return(<div className="relative w-full h-[80vh] rounded-2xl overflow-hidden"><div ref={containerRef} className="w-full h-full"/><div className="absolute top-4 left-4 bg-black/40 text-white backdrop-blur-md p-4 rounded-2xl shadow-lg space-y-3 min-w-[260px]"><div className="text-sm opacity-90">Interactive Dot Globe</div><div className="flex items-center justify-between gap-3"><label className="text-xs opacity-80">Dot count</label><input type="range" min={800} max={12000} step={200} value={pointCount} onChange={e=>setPointCount(parseInt(e.target.value,10))} className="w-40"/><span className="text-xs tabular-nums opacity-80 w-10 text-right">{pointCount}</span></div><div className="flex items-center justify-between gap-3"><label className="text-xs opacity-80">Dot size</label><input type="range" min={0.006} max={0.03} step={0.002} value={dotSize} onChange={e=>setDotSize(parseFloat(e.target.value))} className="w-40"/><span className="text-xs tabular-nums opacity-80 w-10 text-right">{dotSize.toFixed(3)}</span></div><div className="flex items-center justify-between gap-3"><label className="text-xs opacity-80">Auto-rotate</label><input type="checkbox" checked={autoRotate} onChange={e=>setAutoRotate(e.target.checked)}/></div><div className="flex items-center justify-between gap-3"><label className="text-xs opacity-80">Rotate speed</label><input type="range" min={0.1} max={3} step={0.1} value={rotateSpeed} onChange={e=>setRotateSpeed(parseFloat(e.target.value))} className="w-40"/><span className="text-xs tabular-nums opacity-80 w-10 text-right">{rotateSpeed.toFixed(1)}</span></div><div className="flex items-center gap-2 pt-1"><button onClick={handleResetCamera} className="px-3 py-1.5 rounded-xl bg-white/10 hover:bg-white/20 transition text-xs">Reset camera</button></div></div></div>)}
function createPointCloud(count=4000,size=0.01){const radius=1;const positions=new Float32Array(count*3);const golden=(1+Math.sqrt(5))/2;const angleInc=2*Math.PI/golden;for(let i=0;i<count;i++){const t=i/(count-1);const y=1-2*t;const r=Math.sqrt(1-y*y);const phi=i*angleInc;const x=Math.cos(phi)*r;const z=Math.sin(phi)*r;positions[i*3+0]=x*radius;positions[i*3+1]=y*radius;positions[i*3+2]=z*radius}const geometry=new THREE.BufferGeometry();geometry.setAttribute("position",new THREE.BufferAttribute(positions,3));geometry.computeBoundingSphere();const material=new THREE.PointsMaterial({color:new THREE.Color(0xbcd2ff),size:size,sizeAttenuation:true,depthWrite:false,transparent:true,opacity:0.85});const points=new THREE.Points(geometry,material);points.rotation.y=0.8;points.rotation.x=-0.2;return points}function disposePoints(points){if(!points)return;if(points.geometry)points.geometry.dispose();if(points.material)points.material.dispose()}